---
layout: post
title: Safe roguelike programming (continued)
date: '2016-11-03T04:08:00.001-07:00'
author: smelC
tags: 
modified_time: '2016-11-03T04:08:40.355-07:00'
blogger_id: tag:blogger.com,1999:blog-989893979829990763.post-7003890575020863251
blogger_orig_url: https://hgamesdev.blogspot.com/2016/11/safe-roguelike-programming-continued.html
---

<p><a href="http://hgamesdev.blogspot.com/2016/02/safe-roguelike-programming-in-java.html">Earlier this year</a>, I spoke how I code in a manner to ease future extensions of my roguelike. To make it short, my point was “use enumerations whenever possible, and do switchs on them, <strong>without the default clause</strong>“, so that the compiler warns you when you later extend the enumeration.</p> <p>Today, I’d like to continue down this road. In the last weeks I added a new type of terrain to <a href="http://www.schplaf.org/hgames/">Dungeon Mercenary</a>: <a href="https://twitter.com/hgamesdev/status/780676336180486144">pits</a>. So I was very proud to extend my <em>map cell</em> enumeration from <code>{Floor, Wall}</code> to <code>{Floor, Wall, Pit}</code>. But while updating my code, I witnessed a bad design. At some point I introduced a method <code>getAllTerrainKind()</code> to my <em>map cell</em> interface whose return type was the following enumeration:</p> <ul><li>PIT</li><li>WALL</li><li>ALTAR</li><li>CHEST</li><li>FORGE</li><li>STAIR_DOWN</li><li>STAIR_UP</li><li>BARREL</li><li>DOOR</li><li>EMPTY</li><li>GRASS</li><li>SHALLOW_WATER</li><li>WATER</li></ul> <p>This enumeration was very convenient as it could be retrieved from any map cell directly (i.e. the method was in the toplevel map cell interface). But it suffered from multiple defects:</p> <ul><li>First, it was messing up terrain kinds and features of cells; so it was hiding that a BARREL can be on GRASS.</li><li>As a consequence, it forced implementors to do some decision making on their own, as the implementation in the concrete <em>floor</em> map cell was doing:</li></ul>   <pre style="" class="prettyprint prettyprinted"><code class="language-.java"><span class="com">/* Must be coherent with LevelUtils::acceptsBarrel */</span><span class="pln"><br /></span><span class="lit">@Override</span><span class="pln"><br /></span><span class="kwd">public</span><span class="pln"> </span><span class="typ">AllTerrainKind</span><span class="pln"> getTerrainKind</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lop </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">doorStatus</span><span class="pun">.</span><span class="pln">isDoor</span><span class="pun">())</span><span class="pln"><br />            </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">AllTerrainKind</span><span class="pun">.</span><span class="pln">DOOR</span><span class="pun">;</span><span class="pln"><br />        </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">barrelKind </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"><br />            </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">AllTerrainKind</span><span class="pun">.</span><span class="pln">BARREL</span><span class="pun">;</span><span class="pln"><br />        </span><span class="kwd">else</span><span class="pln"><br />            </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">AllTerrainKind</span><span class="pun">.</span><span class="pln">EMPTY</span><span class="pun">;</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">switch</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lop</span><span class="pun">.</span><span class="pln">kind</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="com">/*<br />         * If there's grass, we can forget it if there's a barrel on<br />         * top. In particular, fire doesn't affect grass<br />         * with a barrel.<br />         */</span><span class="pln"><br />        </span><span class="kwd">case</span><span class="pln"> GRASS</span><span class="pun">:</span><span class="pln"><br />            </span><span class="com">/* Those behave like empty, except for the symbol: */</span><span class="pln"><br />        </span><span class="kwd">case</span><span class="pln"> CHASM_NEIGHBOR</span><span class="pun">:</span><span class="pln"><br />        </span><span class="kwd">case</span><span class="pln"> GRAVAS</span><span class="pun">:</span><span class="pln"><br />        </span><span class="kwd">case</span><span class="pln"> TOMB</span><span class="pun">:</span><span class="pln"><br />            </span><span class="kwd">return</span><span class="pln"> barrelKind </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="typ">AllTerrainKind</span><span class="pun">.</span><span class="pln">EMPTY </span><span class="pun">:</span><span class="pln"> </span><span class="typ">AllTerrainKind</span><span class="pun">.</span><span class="pln">BARREL</span><span class="pun">;</span><span class="pln"><br />        </span><span class="kwd">case</span><span class="pln"> LAVA</span><span class="pun">:</span><span class="pln"><br />        </span><span class="kwd">case</span><span class="pln"> MUD</span><span class="pun">:</span><span class="pln"><br />            </span><span class="kwd">throw</span><span class="pln"> </span><span class="typ">Utils</span><span class="pun">.</span><span class="pln">newImplementMeISE</span><span class="pun">();</span><span class="pln"><br />        </span><span class="kwd">case</span><span class="pln"> SHALLOW_WATER</span><span class="pun">:</span><span class="pln"><br />            </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">AllTerrainKind</span><span class="pun">.</span><span class="pln">SHALLOW_WATER</span><span class="pun">;</span><span class="pln"><br />        </span><span class="kwd">case</span><span class="pln"> WATER</span><span class="pun">:</span><span class="pln"><br />            </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">AllTerrainKind</span><span class="pun">.</span><span class="pln">WATER</span><span class="pun">;</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"><br />        </span><span class="kwd">throw</span><span class="pln"> </span><span class="typ">Utils</span><span class="pun">.</span><span class="pln">newUnmatchedISE</span><span class="pun">(</span><span class="pln">lop</span><span class="pun">.</span><span class="pln">kind</span><span class="pun">);</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>God this is terrible to have such decision making in a <em>data</em> class. It means that the <em>Floor</em> class was deciding for the entire rest of the code that, well, you’ll never be able to take into account that a barrel can be on grass; and there was a weird interaction between tombs and barrels (see this inlined conditional ?).</p> <p>So I decided to bust this enumeration and forced myself to do it the proper way, <em>in every calling point</em>. The right way being:</p> <ul><li>Check if a map cell is a pit, a wall, or a floor.</li><li>Then, recurse into each possibility: <br><ul><li>A wall can be a vanilla wall, an altar, a forge, or a chest.</li><li>A pit cannot contain any terrain</li><li>A floor, which can have terrain (exactly one of lava, water, grass, tomb, etc.) and can have multiple features/attributes.</li></ul></li></ul> <p>I’d like to emphasize one point: one should encode an exclusive disjunction (i.e. a list of possibilities where exactly one possibility is possible) by an enumeration and do switches on this enumeration; whereas for features/attributes (of which an element can have multiple of them) one should again encode them with an enumeration, and do switches on this enumeration <em>within loops on the possible list of features</em>. </p> <p>To exemplify that, in Dungeon Mercenary, a floor cell can have zero to many of the following attributes:</p> <ul><li>BARREL</li><li>DOOR</li><li>ITEM</li><li>ON_FIRE</li><li>TRAP</li></ul> <p>Some of the attributes are exclusive, like having a barrel and a door, but some aren’t: barrel and item, barrel and trap, and whatever and on fire. But that should not be relied upon: in general, attributes are not exclusive. So what’s the safe way to handle them ? It’s to iterate on all possible attributes, and check whether they are present whenever inspecting a cell. An example code is the one checking if a barrel can be placed on a cell:</p>   <pre style="" class="prettyprint prettyprinted"><code class="language-.java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> acceptsBarrel</span><span class="pun">(</span><span class="typ">IMapCell</span><span class="pln"> sge</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">switch</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sge</span><span class="pun">.</span><span class="pln">getMapCellKind</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">case</span><span class="pln"> FLOOR</span><span class="pun">:</span><span class="pln"><br />        </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">IMapCell</span><span class="pun">.</span><span class="typ">Floor</span><span class="pln"> stack </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">IMapCell</span><span class="pun">.</span><span class="typ">Floor</span><span class="pun">)</span><span class="pln"> sge</span><span class="pun">;</span><span class="pln"><br />        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">FloorAttribute</span><span class="pln"> fa </span><span class="pun">:</span><span class="pln"> </span><span class="typ">FloorAttribute</span><span class="pun">.</span><span class="pln">values</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">stack</span><span class="pun">.</span><span class="pln">hasAttribute</span><span class="pun">(</span><span class="pln">fa</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />                </span><span class="kwd">switch</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fa</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />                </span><span class="kwd">case</span><span class="pln"> BARREL</span><span class="pun">:</span><span class="pln"><br />                </span><span class="kwd">case</span><span class="pln"> DOOR</span><span class="pun">:</span><span class="pln"><br />                    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln"><br />                </span><span class="kwd">case</span><span class="pln"> ITEM</span><span class="pun">:</span><span class="pln"><br />                </span><span class="kwd">case</span><span class="pln"> TRAP</span><span class="pun">:</span><span class="pln"><br />                </span><span class="kwd">case</span><span class="pln"> ON_FIRE</span><span class="pun">:</span><span class="pln"><br />                    </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln"><br />                </span><span class="pun">}</span><span class="pln"><br />            </span><span class="pun">}</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"><br />        </span><span class="pun">...</span><span class="pln"><br />    </span><span class="kwd">case</span><span class="pln"> CHASM</span><span class="pun">:</span><span class="pln"><br />        </span><span class="com">/* Barrel will fall to next level */</span><span class="pln"><br />        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln"><br />    </span><span class="kwd">case</span><span class="pln"> WALL</span><span class="pun">:</span><span class="pln"><br />        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br />    </span><span class="kwd">throw</span><span class="pln"> </span><span class="typ">Utils</span><span class="pun">.</span><span class="pln">newUnmatchedISE</span><span class="pun">(</span><span class="pln">sge</span><span class="pun">.</span><span class="pln">getMapCellKind</span><span class="pun">());</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>This code is safe w.r.t. future extensions and it doesn’t rely on some of the exclusivity of attributes mentioned above (doors and barrels for example).</p> <p>Hope this’ll help fellow roguelike programmers!</p> <blockquote>  <p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>