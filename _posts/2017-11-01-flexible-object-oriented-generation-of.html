---
layout: post
title: Flexible object-oriented generation of monsters
date: '2017-11-01T14:23:00.003-07:00'
author: smelC
tags: 
modified_time: '2017-11-01T14:23:48.284-07:00'
blogger_id: tag:blogger.com,1999:blog-989893979829990763.post-4091617804576305012
blogger_orig_url: https://hgamesdev.blogspot.com/2017/11/flexible-object-oriented-generation-of.html
---

<p>Recently, I’ve revamped Dungeon Mercenary’s monsters generation. Previously I was using a simple <a href="https://github.com/smelc/hgamesrhogue/blob/master/src/main/java/com/hgames/rhogue/rng/ProbabilityTable.java">PriorityTable</a> which mapped every monster kind to an int probability. This means that, to generate n monsters, a dice was rolled ‘n’ times, on the interval <em>0-sum of probability of all monsters</em> and the monster whose probability-interval was rolled on was picked. For example, the probabilities for depth 5 was expressed as follows:</p>   <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">likeliness</span>(MKind mkind) {<br />        <span class="hljs-keyword">switch</span> (depth) {<br />        <span class="hljs-keyword">case</span> ...:<br />        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br />                <span class="hljs-keyword">if</span> (mkind == KOBOLD)<br />                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br />                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mkind == CHAOS_DOG)<br />                        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br />                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mkind == CHAOS_FAIRY)<br />                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br />                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mkind == GOBLIN)<br />                        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br />                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mkind == GOBLIN_NECROMANCER)<br />                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br />                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mkind == GOBLIN_NINJA)<br />                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br />                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mkind == ORC)<br />                        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br />                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mkind == ORC_SHAMAN)<br />                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br />                <span class="hljs-keyword">else</span><br />                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />        ...</code></pre> <p>The main problem with this approach was that it was inappropriate to generate groups of monsters. In my mind, monsters often come in group, with a few special monsters in there; to spice it up. This was the objective of the generator shown above with the goblin necromancers and the goblin ninjas. My intent was that they would spice up the “vanilla” goblins. However a probability table doesn’t work very well for that purpose, as a few “misplaced” rolls in the table above could make the generator generate more spicy goblins than vanilla goblins. To circumvent that, I’ve introduced a “roulette” generator, that is organized differently. It takes as input the “vanilla” monsters and the spicy monsters; and generate a spicy monsters every 2 or 3 vanilla monsters. I took the occasion to introduce a few combinators to combine subgenerators which I’ll describe too; as the resulting ensemble seems nice to me. Here’s the <a href="https://github.com/smelc/hgamesrhogue/blob/master/src/main/java/com/hgames/rhogue/generation/monsters/group/IMonstersGroupGenerator.java">main interface</a> that is implemented by a variety of small generators, which are combined:</p>   <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMonstersGroupGenerator</span>&lt;<span class="hljs-title">U</span>, <span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IAnimate</span>&gt; {</span><br /><br />    <span class="hljs-javadoc">/**<br />     *<span class="hljs-javadoctag"> @param</span> factory<br />                      A function {@code U -&gt; T}<br />     *<span class="hljs-javadoctag"> @param</span> rng<br />     *            The {@link RNG} to use.<br />     *<span class="hljs-javadoctag"> @param</span> acc<br />     *            Where to record created monsters.<br />     */</span><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generate</span>(IMonstersFactory&lt;U, T&gt; factory, RNG rng, Collection&lt;T&gt; acc);<br /><br />}</code></pre> <p>I know that non object-oriented people will cry at this interface, that has 2 type parameters, and a bound. It’s clearly not the shortest API, but it’s the right way to do it in a library. In this interface, <code>U</code> is the identifier of monsters; which is an enumeration in Dungeon Mercenary and <code>T</code> is the concrete type of monsters (i.e. a single monster, with its attributes, health, damages, etc.). The attentive reader will note that this interface doesn’t mention the number of monsters to generate. This is important when generating group of monsters, as you don’t want the subgenerators to be aware of the number of monsters. It bloats implementations, and is better delegated to the top-level client of these generators (more on that later). There are 3 base generators that implement <code>IMonstersGroupGenerator</code>: <code>Single</code>, <code>And</code>, and <code>Or</code> (that are all defined in <a href="%28https://github.com/smelc/hgamesrhogue/blob/master/src/main/java/com/hgames/rhogue/generation/monsters/group/IMonstersGroupGenerator.java%29">IMonsterGroupGenerator’s file</a>). The <code>Single</code> generator generates a single monster every time it is called, the <code>And</code> generator generates all monsters of the generators to which it delegates (it’s a <em>conjunction</em>), and the <code>Or</code> generator is the old ProbabilityTable-based one (it’s a <em>disjunction</em>). At this point, note that handling the size in these generators would be at best cumbersome. To these 3 base generators, I’ve added the roulette generator described above. This allows to rewrite the code I’ve shown on top of this post as follows:</p>   <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">if</span> (depth == <span class="hljs-number">3</span>) {<br />        <span class="hljs-keyword">final</span> ProbabilityTable&lt;IMonstersGroupGenerator&lt;MKind, IAnimate&gt;&gt; table = ProbabilityTable.create(<span class="hljs-number">5</span>); <span class="hljs-comment">// input to a disjunction</span><br />        table.add(KOBOLD, <span class="hljs-comment">/* probability */</span> <span class="hljs-number">1</span>);<br />        table.add(CHAOS_DOG, <span class="hljs-number">2</span>);<br />        table.add(CHAOS_FAIRY, <span class="hljs-number">1</span>);<br />        table.add(roulette(GOBLIN, GOBLINS_SPICING), <span class="hljs-number">3</span>);<br />        table.add(roulette(ORC, ORC_SHAMAN), <span class="hljs-number">4</span>);<br />        <span class="hljs-keyword">return</span> MonstersGenerator.create(or(table)); <span class="hljs-comment">// Calls the Or generator (disjunction), that takes a probability table as input</span><br />}</code></pre> <p>In this code, <code>GOBLINS_SPICING</code> is a disjunctive-generator that generates either a goblin necromancer or a goblin ninja. This framework is quite expressive and concise. This is in part due to the fact that the type of identifiers (<code>U</code> in IMonstersGroupGenerator) is itself an implementation of IMonstersGroupGenerator, which allows to pass a monster’s identifier as a generator (it behaves exaclty like the <code>Single</code> generator). To be able to do that, the group generators must be real functions, i.e. they should not keep any state (as identifiers are inadequate to do that). Keeping state would anyway be cumbersome, for example you don’t want to store the RNG. It’s also important to have functions if you wanna save allocations by making some generators static. For example, <code>GOBLINS_SPICING</code> is static, as it’s a fixed disjunction on the fixed identifiers of spicy goblins. Another example of flexibility is when you want to force generation to include some monster(s). In this case, you simply conjunct a generator for these “must” monsters with your usual generator.</p> <p>Finally, to generate a given number of monsters, it suffices to repeatedly call a group generator, until the accumulator (the third parameter of IMonstersGroupGenerator’s only method) has the appropriate size. Because the <em>roulette</em> generator generates spicy monsters after bunches of vanilla monsters, you’ll never end up with more spicy monsters than vanilla monsters when iteratively calling a roulette generator. For clarity, I’ve introduced a different interface for generators that are size-aware: <a href="https://github.com/smelc/hgamesrhogue/blob/master/src/main/java/com/hgames/rhogue/generation/monsters/generator/IMonstersGenerator.java">IMonstersGenerator</a>.</p> <p>As usual with my libraries, all this code is in the public domain (in library <a href="https://github.com/smelc/hgamesrhogue/">hgamesrhogue</a>), so you head over to this link, you steal what you want, you modify it; it’s all up to you!</p> <blockquote>  <p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>